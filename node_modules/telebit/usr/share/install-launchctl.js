'use strict';

var PromiseA;
try {
  PromiseA = require('bluebird');
} catch(e) {
  /*global Promise*/
  PromiseA = Promise;
}

var Launcher = module.exports;
Launcher.create = function (things) {
  things = things || {};
  var launcher = {};
  var installLauncher = require('./template-launcher');
  return launcher;
};

Launcher.install = function (things, fn) {
  if (!fn) { fn = function (err) { if (err) { console.error(err); } }; }
  // in some future version we can take this file out
  // and accept process.env from things

  // Right now this is just for npm install -g and npx
  if (things.env) {
    things.env.PATH = things.env.PATH || process.env.PATH;
  } else {
    things.env = process.env;
  }
  things.argv = things.argv || process.argv;
  things._execOpts = { windowsHide: true, env: things.env };
  var telebitRoot = path.join(__dirname, '../..');
  var vars = {
    telebitPath: telebitRoot
  , telebitUser: os.userInfo().username
  , telebitGroup: (/^darwin/i.test(os.platform()) ? 'staff' : os.userInfo().username)
  , telebitRwDirs: [
      telebitRoot
    , path.join(os.homedir(), '.config/telebit')
    , path.join(os.homedir(), '.local/share/telebit')
    ]
  , telebitNode: (things.argv[0]||'').replace(/\.exe/i, '') // path.join(telebitRoot, 'bin/node')
  , telebitBin: path.join(telebitRoot, 'bin/telebit')
  , telebitdBin: path.join(telebitRoot, 'bin/telebitd')
  , telebitJs: path.join(telebitRoot, 'bin/telebit.js')
  , telebitdJs: path.join(telebitRoot, 'bin/telebitd.js')
  , telebitConfig: path.join(os.homedir(), '.config/telebit/telebit.yml')
  , telebitdConfig: path.join(os.homedir(), '.config/telebit/telebitd.yml')
  , TELEBIT_LOG_DIR: path.join(os.homedir(), '.local/share/telebit/var/log')
  , TELEBIT_SOCK_DIR: path.join(os.homedir(), '.local/share/telebit/var/run')
  };
  vars.telebitBinTpl = path.join(telebitRoot, 'usr/share/dist/bin/telebit.tpl');
  vars.telebitNpm = path.resolve(vars.telebitNode, '../npm');
  vars.nodePath = path.resolve(vars.telebitNode, '../lib/node_modules');
  vars.npmConfigPrefix = path.resolve(vars.telebitNode, '..');
  vars.userspace = (!things.telebitUser || (things.telebitUser === os.userInfo().username)) ? true : false;
  if (-1 === vars.telebitRwDirs.indexOf(vars.npmConfigPrefix)) {
    vars.telebitRwDirs.push(vars.npmConfigPrefix);
  }
  vars.telebitRwDirs = vars.telebitRwDirs.join(' ');
  var launchers = {
    'node': function () {
      var fs = require('fs');
      var spawn = require('child_process').spawn;
      var logpath = path.join(os.homedir(), '.local/share/telebit/var/log');
      try {
        mkdirp.sync(logpath);
      } catch(e) {
        if (fn) { fn(e); return; }
        return;
      }
      var stdout = fs.openSync(path.join(logpath, 'info.log'), 'a');
      var stderr = fs.openSync(path.join(logpath, 'error.log'), 'a');

      var killed = 0;
      var err;
      var args = [
        path.join(telebitRoot, 'bin/telebitd.js')
      , 'daemon'
      , '--config'
      , vars.telebitdConfig
      ];
      var subprocess = spawn(
        vars.telebitNode
      , args
      , { detached: true
        , stdio: [ 'ignore', stdout, stderr ]
        }
      );
      //console.log('[debug]', vars.telebitNode, args.join(' '));
      subprocess.unref();
      subprocess.on('error', function (_err) {
        err = _err;
        killed += 1;
      });
      subprocess.on('exit', function (code, signal) {
        if (!err) { err = new Error('' + code + ' ' + signal + ' failure to launch'); }
        killed += 1;
      });

      // Two things:
      // 1) wait to see if the process dies
      // 2) wait to give time for the socket to connect
      setTimeout(function () {
        if (fn) { fn(err); return; }
      }, 1.75 * 1000);
      return;
    }
  , 'launchctl': function () {
      var launcher = path.join(os.homedir(), 'Library/LaunchAgents/cloud.telebit.remote.plist');
      try {
        mkdirp.sync(path.join(os.homedir(), 'Library/LaunchAgents'));
        installLauncher.sync({
            file: {
              tpl: vars.telebitBinTpl
            , launcher: path.join(vars.telebitPath, 'bin/telebit')
            , executable: true
          }
        , vars: vars
        });
        installLauncher({
          file: {
              tpl: path.join(vars.telebitPath, 'usr/share/dist/etc/skel/Library/LaunchAgents/cloud.telebit.remote.plist.tpl')
            , launcher: launcher
            }
          , vars: vars
        });
        var launcherstr = (vars.userspace ? "" : "sudo ") + "launchctl ";
        var execstr = launcherstr + "unload -w " + launcher;
        exec(execstr, things._execOpts, function (/*err, stdout, stderr*/) {
          // we probably only need to skip the stderr (saying that it can't stop something that isn't started)
          //err = Launcher._getError(err, stderr);
          //if (err) { fn(err); return; }
          //console.log((stdout||'').trim());
          //console.log('unload worked?');
          execstr = launcherstr + "load -w " + launcher;
          exec(execstr, things._execOpts, function (err, stdout, stderr) {
            err = Launcher._getError(err, stderr);
            if (err) { fn(err); return; }
            //console.log((stdout||'').trim());
            //console.log('load worked?');
            setTimeout(function () {
              fn(null);
            }, 1.25 * 1000);
          });
        });
      } catch(e) {
        console.error("'" + launcher + "' error:");
        console.error(e);
        if (fn) { fn(e); return; }
      }
    }
  };

  function run(err, launcher) {
    if (err) {
      console.error("No luck with '" + launcher + "', trying a child process instead...");
      console.error(err);
      launcher = 'node';
    }

    if (launchers[launcher]) {
      // console.log('Launching with launcher ' + launcher);
      mkdirp.sync(path.join(vars.telebitPath, 'bin'));
      mkdirp.sync(vars.TELEBIT_LOG_DIR);
      mkdirp.sync(vars.TELEBIT_SOCK_DIR);
      launchers[launcher]();
      return;
    } else {
      console.error("No launcher handler for '" + launcher+ "'");
    }
  }

  things._vars = vars;
  things._userspace = vars.userspace;
  Launcher._detect(things, run);
};
